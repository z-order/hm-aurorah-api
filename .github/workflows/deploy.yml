# This is a basic workflow to help you get started with Actions

name: Deploy to AWS EC2 Aurora Development/Production Server

# Controls when the workflow will run
on:
    # Triggers the workflow on push or pull request events but only for the "main" branch
    push:
        branches: ["main"]
    pull_request:
        branches: ["main"]

    # Allows you to run this workflow manually from the Actions tab
    workflow_dispatch:

# Permissions
permissions:
    id-token: write # for GitHub Actions OIDC
    contents: read # for reading the code

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
    deploy:
        name: Deploy to Host
        runs-on: ubuntu-latest
        environment:
            name: ${{ github.ref == 'refs/heads/main' && 'AWS-EC2-DEVELOPMENT' || github.ref == 'refs/heads/production' && 'AWS-EC2-PRODUCTION' }}

        steps:
            - name: Checkout code
              uses: actions/checkout@v4

            # Temporary for the later solution: Stop SSH-ing from GitHub. Use SSM instead.
            #
            # SSH key authentication (deprecated) -> This way has the issues on setting AWS security groups and firewall rules for the GitHub Action IPs (https://api.github.com/meta)
            #
            - name: Setup SSH key
              run: |
                  mkdir -p ~/.ssh
                  echo "${{ secrets.SSH_KEY }}" > ~/.ssh/id_rsa
                  chmod 600 ~/.ssh/id_rsa

            # AWS Systems Manager (OIDC) needs 22 port open for the GitHub Action IPs (https://api.github.com/meta)
            #
            # Solution: Stop SSH-ing from GitHub. Use SSM instead.
            #
            # - name: Configure AWS credentials (OIDC)
            #   uses: aws-actions/configure-aws-credentials@v4
            #   with:
            #       role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-oidc-role
            #       aws-region: ${{ secrets.AWS_REGION }}
            #
            # - name: Verify AWS Login
            #   run: aws sts get-caller-identity
            #
            # - name: Setup SSH via AWS Systems Manager
            #   run: |
            #       mkdir -p ~/.ssh
            #       ssh-keygen -t rsa -b 2048 -N '' -f ~/.ssh/id_rsa -q
            #       aws ec2-instance-connect send-ssh-public-key \
            #         --instance-id ${{ secrets.INSTANCE_ID }} \
            #         --availability-zone ${{ secrets.AVAILABILITY_ZONE }} \
            #         --instance-os-user ${{ secrets.USERNAME }} \
            #         --ssh-public-key file://~/.ssh/id_rsa.pub

            - name: Add host to known_hosts
              run: |
                  ssh-keyscan -p ${{ secrets.PORT }} -H ${{ secrets.HOST }} >> ~/.ssh/known_hosts

            - name: Rsync files to host
              run: |
                  rsync -avz --delete -e "ssh -p ${{ secrets.PORT }}" ./ ${{ secrets.USERNAME }}@${{ secrets.HOST }}:${{ secrets.DEST }}

            - name: Create .env.postgres file on remote host
              run: |
                  ssh -p ${{ secrets.PORT }} ${{ secrets.USERNAME }}@${{ secrets.HOST }} "cd ${{ secrets.DEST }}/deployment && cat > .env.postgres << 'EOF'
                  POSTGRES_DB=${{ secrets.POSTGRES_DB }}
                  POSTGRES_USER=${{ secrets.POSTGRES_USER }}
                  POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
                  EOF
                  "

            - name: Create .env.minio file on remote host
              run: |
                  ssh -p ${{ secrets.PORT }} ${{ secrets.USERNAME }}@${{ secrets.HOST }} "cd ${{ secrets.DEST }}/deployment && cat > .env.minio << 'EOF'
                  MINIO_ROOT_USER=${{ secrets.MINIO_ROOT_USER }}
                  MINIO_ROOT_PASSWORD=${{ secrets.MINIO_ROOT_PASSWORD }}
                  EOF
                  "

            - name: Create .env.${{ vars.DEPLOY_ENV || 'production' }} file on remote host
              run: |
                  ssh -p ${{ secrets.PORT }} ${{ secrets.USERNAME }}@${{ secrets.HOST }} "cd ${{ secrets.DEST }}/deployment && cat > .env.${{ vars.DEPLOY_ENV || 'production' }} << 'EOF'
                  API_KEY1=${{ secrets.API_KEY1 }}
                  API_KEY2=${{ secrets.API_KEY2 }}
                  API_KEY3=${{ secrets.API_KEY3 }}
                  API_KEY4=${{ secrets.API_KEY4 }}
                  API_KEY5=${{ secrets.API_KEY5 }}
                  API_KEY6=${{ secrets.API_KEY6 }}
                  API_KEY7=${{ secrets.API_KEY7 }}
                  API_KEY8=${{ secrets.API_KEY8 }}
                  API_KEY9=${{ secrets.API_KEY9 }}
                  REDIS_URL=${{ vars.REDIS_URL }}
                  POSTGRES_URL=${{ secrets.POSTGRES_URL }}
                  LANGGRAPH_API_URL=${{ vars.LANGGRAPH_API_URL }}
                  EOF
                  "

            - name: Run remote deploy script
              run: |
                  ssh -p ${{ secrets.PORT }} ${{ secrets.USERNAME }}@${{ secrets.HOST }} "cd ${{ secrets.DEST }} && bash -l -c './deployment/deploy.sh ${{ vars.DEPLOY_ENV || 'production' }} api'"
